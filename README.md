# Comradewolf
## О чем проект
Comradewolf — часть бо́льшего проекта, который должен позволить людям осуществлять быстрые выгрузки из таблиц 
с данными, не увеличивая количество агрегированных срезов (отдельных таблиц) в базе для редких вычислений

Проект реализует похожие принципы, что и классические OLAP-кубы, но с помощью реляционной базы данных.

## Задачи проекта
- Получить от пользователя набор показателей и метрик с необходимыми вычислениями
- Выбрать лучший срез для выборки данных
- Досчитать несуществующие метрики (если надо)
- Отдать данные пользователю

## Логика работы проекта. Без подробностей
У вас есть большая витрина с чеками:
```SQL
SELECT
     date -- дата
    ,month_no -- номер месяца
    ,year_no -- номер года
    ,week_no -- номер недели
    ,reciept_no -- номер чека
    ,sku -- sku
    ,pcs -- кол-во штук
    ,rub -- сумма рублей
FROM reciepts
```
На основе витрины ```reciepts``` создается ряд витрин с группировками. 
Потребность в группировках должна рассматриваться совместно с бизнесом. 
Формирование и наполнение витрин остается на совести Data-инженеров и вынесено за рамками проекта

Формируем доп витрины

```SQL
-- Витрина на уровне день-SKU
CREATE TABLE date_sku_sales AS

    SELECT
         date
        ,month_no
        ,year_no
        ,week_no
        ,sku
        ,SUM(pcs) as sum_pcs
        ,SUM(rub) as sum_rub
    FROM reciepts
    GROUP BY 
         date
        ,month_no
        ,year_no
        ,week_no
        ,sku
```

```SQL
-- Витрина на уровне месяц-год-SKU
CREATE TABLE month_sku_sales AS

    SELECT
         month_no
        ,year_no
        ,sku
        ,COUNT(DISTINCT reciept_no) as distinct_reciepts
        ,SUM(pcs) as sum_pcs
        ,SUM(rub) as sum_rub
    FROM reciepts
    GROUP BY 
         month_no
        ,year_no
        ,sku
```

Витрин может быть больше, с любыми группировками


Идея состоит в том, что простой SELECT без GROUP BY отрабатывает на порядок быстрее, чем сложные вычисления. 
А если GROUP BY, не избежать, то чем меньше строк в вычислении, тем лучше

### Отработка запросов
#### Случай 1
Пользователь запрашивает данные на уровне, которая есть в нашей таблице
- Месяц = 11
- Год = 2024
- SKU в списке (123, 234)
- Кол-во штук проданного
- Кол-во чеков

Система отдаст данные из наиболее подходящей таблицы:
```SQL
SELECT
     month_no
    ,year_no
    ,sku
    ,distinct_reciepts
    ,sum_pcs
FROM month_sku_sales
WHERE 
        month_no = 11
    AND year_no = 2024
    AND sku IN (123, 234)
```

#### Случай 2
Пользователь запрашивает данные на уровне, которая есть в нашей таблице
- День
- Неделя
- Месяц = 11
- Год = 2024
- Кол-во штук проданного

Система отдаст данные из наиболее подходящей таблицы:
```SQL
SELECT
     date
    ,month_no
    ,year_no
    ,sku
    ,distinct_reciepts
    ,sum_pcs
FROM date_sku_sales
WHERE 
        month_no = 11
    AND year_no = 2024
```

#### Случай 3
Пользователь запрашивает данные на уровне, которая есть в нашей таблице
- День = '2024-01-01'
- Кол-во уникальных чеков

Подготовленного среза нет, поэтому запрос сформируется с GROUP BY:
```SQL
SELECT
     date
    ,COUNT(DISTINCT reciept_no) as count_distinct__reciept_no
FROM reciepts
WHERE 
        date = '2024-01-01'
GROUP BY
     date
```

#### Нюансы
При данной реализации фактовых таблиц, запрос
- День
- SKU
- Сумма шт

Будет сформировано запросом:
```SQL
SELECT
     date
    ,sku
    ,SUM(sum_rub) as sum__sum_rub
FROM date_sku_sales
GROUP BY 
     date
    ,sku
```

Чтобы избавиться от ненужных GROUP BY, необходимо зарегистрировать view (например, ```view_date_sku_sales``), без материализации, убрав месяц, год и неделю. 
В этом случае, запрос выполнится следующим образом:

```SQL
SELECT 
     date
    ,sku
    ,sum_rub
FROM view_date_sku_sales
```
